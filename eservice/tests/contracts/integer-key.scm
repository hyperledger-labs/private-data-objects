;; Copyright 2018 Intel Corporation
;;
;; Licensed under the Apache License, Version 2.0 (the "License");
;; you may not use this file except in compliance with the License.
;; You may obtain a copy of the License at
;;
;;     http://www.apache.org/licenses/LICENSE-2.0
;;
;; Unless required by applicable law or agreed to in writing, software
;; distributed under the License is distributed on an "AS IS" BASIS,
;; WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
;; See the License for the specific language governing permissions and
;; limitations under the License.

(define-macro (assert pred . message) `(if (not ,pred) (throw ,@message)))
(define (coerce-number value) (if (number? value) value (string->number value)))
(define-class signing-keys (instance-vars (private-key "") (public-key "")))
(define-method signing-keys (initialize-instance . args) (if (string=? public-key "") (let ((_keys_ (ecdsa-create-signing-keys))) (instance-set! self 'private-key (car _keys_)) (instance-set! self 'public-key (cadr _keys_)))))
(define-method signing-keys (get-public-signing-key) public-key)
(define-method signing-keys (sign message) (assert (string? message) "message must be a string" message) (assert (not (string=? private-key "")) "not initialized for signing") (ecdsa-sign-message message private-key))
(define-method signing-keys (sign-expression expression) (send self 'sign (expression->string expression)))
(define-method signing-keys (verify message signature) (assert (string? message) "message must be a string" message) (assert (string? signature) "signature must be a string" signature) (ecdsa-verify-signature message signature public-key))
(define-method signing-keys (verify-expression expression signature) (send self 'verify (expression->string expression) signature))
(define-class encryption-keys (instance-vars (private-key "") (public-key "")))
(define-method encryption-keys (initialize-instance . args) (if (string=? public-key "") (let ((_keys_ (rsa-create-keys))) (instance-set! self 'private-key (car _keys_)) (instance-set! self 'public-key (cadr _keys_)))))
(define-method encryption-keys (get-public-encryption-key) public-key)
(define-method encryption-keys (encrypt message) (assert (string? message) "message must be a string" message) (assert (not (string=? private-key "")) "not initialized for encryption") (rsa-encrypt message public-key))
(define-method encryption-keys (encrypt-expression expression) (send self 'encrypt (expression->string expression)))
(define-method encryption-keys (decrypt-expression cipher) (string->expression (send self 'decrypt cipher)))
(define-method encryption-keys (decrypt cipher) (assert (string? cipher) "cipher text must be a string" cipher) (rsa-decrypt cipher private-key))
(define-class base-contract (instance-vars (creator "") (contract-signing-keys #f) (contract-encryption-keys #f)))
(define-method base-contract (initialize-instance . args) (if (string=? creator "") (instance-set! self 'creator (get ':message 'originator))) (if (not contract-signing-keys) (instance-set! self 'contract-signing-keys (make-instance signing-keys))) (if (not contract-encryption-keys) (instance-set! self 'contract-encryption-keys (make-instance encryption-keys))))
(define-method base-contract (get-creator) creator)
(define-const-method base-contract (get-public-encryption-key) (send contract-encryption-keys 'get-public-encryption-key))
(define-const-method base-contract (get-public-signing-key) (send contract-signing-keys 'get-public-signing-key))
(define-class counter (instance-vars (key "") (value 0) (owner "") (active #t)))
(define-method counter (initialize-instance . args) (if (string=? owner "") (instance-set! self 'owner (get ':message 'originator))))
(define-method counter (externalize . args) (if (member 'full args) `(make-instance ,((*colon-hook* 'class-name oops) self) (key ,key) (value ,value) (owner ,owner) (active ,active)) `(make-instance ,((*colon-hook* 'class-name oops) self) (key ,key) (value ,value) (owner ,owner))))
(define-method counter (serialize) (let ((op (open-output-string))) (write (send self 'externalize) op) (get-output-string op)))
(define-method counter (get-key) key)
(define-method counter (get-value) value)
(define-method counter (inc v) (assert active "cannot change the value of an inactive counter") (instance-set! self 'value (+ value v)))
(define-method counter (dec v) (assert active "cannot change the value of an inactive counter") (assert (<= v value) "decrement must be less than the current value") (instance-set! self 'value (- value v)))
(define-method counter (is-less-than? c) (assert (or (instance? c) (integer? c)) "invalid value for comparison" c) (if (instance? c) (< value (send c 'get-value)) (< value c)))
(define-method counter (is-greater-than? c) (assert (or (instance? c) (integer? c)) "invalid value for comparison" c) (if (instance? c) (> value (send c 'get-value)) (> value c)))
(define-method counter (get-owner) owner)
(define-method counter (set-owner new-owner) (assert active "cannot change the owner of an inactive counter") (instance-set! self 'owner new-owner))
(define-method counter (is-owner? requestor) (or (null? owner) (string=? owner requestor)))
(define-method counter (is-active?) active)
(define-method counter (deactivate) (assert active "cannot deactivate an inactive counter") (instance-set! self 'active #f))
(define-method counter (activate) (assert (not active) "cannot activate an active counter") (instance-set! self 'active #t))
(define-class escrow-counter (super-class counter) (instance-vars (escrow-key "")))
(define-method counter (externalize . args) (if (member 'full args) `((key ,key) (value ,value) (owner ,owner) (active ,active) (escrow-key ,escrow-key)) `((key ,key) (value ,value) (owner ,owner))))
(define-method escrow-counter (get-escrow-key) (assert (not active) "counter is not in escrow") escrow-key)
(define-method escrow-counter (set-escrow-key ekey) (assert (not active) "counter is not in escrow") (instance-set! self 'escrow-key ekey))
(define-method escrow-counter (clear-escrow-key) (assert (not active) "counter is not in escrow") (instance-set! self 'escrow-key ""))
(define-method escrow-counter (deactivate . args) (assert active "cannot deactivate an inactive counter") (instance-set! self 'active #f) (let ((public-key (if (pair? args) (car args) ""))) (instance-set! self 'escrow-key public-key)))
(define-method escrow-counter (activate) (assert (not active) "cannot activate an active counter") (instance-set! self 'active #t) (instance-set! self 'escrow-key ""))
(define hash-package (package (define (hash-char char n) (modulo (char->integer char))) (define (hash-symbol sym n) (hash-string (symbol->string sym) n)) (define (hash-number num n) (if (integer? num) (modulo num n) (hash-string (number->string num) n))) (define (hash-string str n) (let ((len (string-length str))) (if (> len 5) (let loop ((h (modulo 264 n)) (i 5)) (if (positive? i) (loop (modulo (+ (* h 256) (char->integer (string-ref str (modulo h len)))) n) (- i 1)) h)) (let loop ((h (- n 1)) (i (- len 1))) (if (>= i 0) (loop (modulo (+ (* h 256) (char->integer (string-ref str i))) n) (- i 1)) h))))) (define (hash-vector vect n) (let ((len (vector-length vect))) (if (> len 5) (let loop ((h (- n 1)) (i 5)) (if (positive? i) (loop (modulo (+ (* h 256) (hash-object (vector-ref vect (modulo h len)) n)) n) (- i 1)) h)) (let loop ((h (- n 1)) (i len)) (if (positive? i) (loop (modulo (+ (* h 256) (hash-object (vector-ref vect (- i 1)) n)) n) (- i 1)) h))))) (define (hash-pair pair n) (let ((v1 (hash-object (car pair) n)) (v2 (hash-object (cdr pair) n))) (modulo (+ v1 v2) n))) (define (hash-object obj n) (cond ((number? obj) (hash-number obj n)) ((char? obj) (hash-char obj n)) ((symbol? obj) (hash-symbol obj n)) ((string? obj) (hash-string obj n)) ((vector? obj) (hash-vector obj n)) ((pair? obj) (hash-pair obj n)) ((null? obj) (modulo 256 n)) ((boolean? obj) (modulo (if obj 257 258) n)) ((eof-object? obj) (modulo 259 n)) ((input-port? obj) (modulo 260 n)) ((output-port? obj) (modulo 261 n)) ((procedure? obj) (modulo 262 n)) (else (modulo 263 n))))))
(define hash (*colon-hook* 'hash-object hash-package))
(define hashv (*colon-hook* 'hash-object hash-package))
(define alist-package (package (define (predicate->asso pred) (cond ((eq? eq? pred) assq) ((eq? = pred) assv) ((eq? eqv? pred) assv) ((eq? char=? pred) assv) ((eq? equal? pred) assoc) ((eq? string=? pred) assoc) (else (lambda (key alist) (let l ((al alist)) (cond ((null? al) #f) ((pred key (caar al)) (car al)) (else (l (cdr al))))))))) (define (inquirer pred) (let ((assofun (predicate->asso pred))) (lambda (alist key) (let ((pair (assofun key alist))) (and pair (cdr pair)))))) (define (associator pred) (let ((assofun (predicate->asso pred))) (lambda (alist key val) (let* ((pair (assofun key alist))) (cond (pair (set-cdr! pair val) alist) (else (cons (cons key val) alist))))))) (define (remover pred) (lambda (alist key) (cond ((null? alist) alist) ((pred key (caar alist)) (cdr alist)) ((null? (cdr alist)) alist) ((pred key (caadr alist)) (set-cdr! alist (cddr alist)) alist) (else (let l ((al (cdr alist))) (cond ((null? (cdr al)) alist) ((pred key (caadr al)) (set-cdr! al (cddr al)) alist) (else (l (cdr al))))))))) (define (alist-map proc alist) (map (lambda (pair) (cons (car pair) (proc (car pair) (cdr pair)))) alist)) (define (alist-for-each proc alist) (for-each (lambda (pair) (proc (car pair) (cdr pair))) alist))))
(define hashtab-package (package (define (make-hash-table k) (make-vector k '())) (define (predicate->hash pred) (cond ((eq? pred eq?) hashq) ((eq? pred eqv?) hashv) ((eq? pred equal?) hash) ((eq? pred =) hashv) ((eq? pred char=?) hashv) ((eq? pred char-ci=?) hashv) ((eq? pred string=?) hash) ((eq? pred string-ci=?) hash) (else (slib:error "unknown predicate for hash" pred)))) (define (predicate->hash-asso pred) (let ((hashfun (predicate->hash pred)) (asso ((*colon-hook* 'predicate->asso alist-package) pred))) (lambda (key hashtab) (asso key (vector-ref hashtab (hashfun key (vector-length hashtab))))))) (define (inquirer pred) (let ((hashfun (predicate->hash pred)) (ainq ((*colon-hook* 'inquirer alist-package) pred))) (lambda (hashtab key) (ainq (vector-ref hashtab (hashfun key (vector-length hashtab))) key)))) (define (associator pred) (let ((hashfun (predicate->hash pred)) (asso ((*colon-hook* 'associator alist-package) pred))) (lambda (hashtab key val) (let* ((num (hashfun key (vector-length hashtab)))) (vector-set! hashtab num (asso (vector-ref hashtab num) key val))) hashtab))) (define (remover pred) (let ((hashfun (predicate->hash pred)) (arem ((*colon-hook* 'remover alist-package) pred))) (lambda (hashtab key) (let* ((num (hashfun key (vector-length hashtab)))) (vector-set! hashtab num (arem (vector-ref hashtab num) key))) hashtab))) (define (hash-map proc ht) (define nht (make-vector (vector-length ht))) (do ((i (+ -1 (vector-length ht)) (+ -1 i))) ((negative? i) nht) (vector-set! nht i ((*colon-hook* 'alist-map alist-package) proc (vector-ref ht i))))) (define (hash-for-each proc ht) (do ((i (+ -1 (vector-length ht)) (+ -1 i))) ((negative? i)) ((*colon-hook* 'alist-for-each alist-package) proc (vector-ref ht i))))))
(define-class key-store (instance-vars (table-size 347) (store #f)) (class-vars (_ht-set_ ((*colon-hook* 'associator hashtab-package) string=?)) (_ht-get_ ((*colon-hook* 'inquirer hashtab-package) string=?)) (_ht-del_ ((*colon-hook* 'remover hashtab-package) string=?))))
(define-method key-store (initialize-instance . args) (if (not store) (instance-set! self 'store ((*colon-hook* 'make-hash-table hashtab-package) table-size))))
(define-const-method key-store (get-state) (let ((result '())) ((*colon-hook* 'hash-for-each hashtab-package) (lambda (key value) (set! result (cons (list key (send value 'externalize 'full)) result))) store) result))
(define-method key-store (create key value) (assert (not (_ht-get_ store key)) "key already exists" key) (_ht-set_ store key value) #t)
(define-method key-store (exists? key) (let ((value (_ht-get_ store key))) value))
(define-method key-store (get key) (let ((value (_ht-get_ store key))) (assert value "key does not exist" key) value))
(define-method key-store (set key value) (let ((oldvalue (_ht-get_ store key))) (assert oldvalue "key does not exist" key) (_ht-del_ store key) (_ht-set_ store key value)))
(define-method key-store (del key) (let ((value (_ht-get_ store key))) (assert value "key does not exist" key) (_ht-del_ store key)))
(define-class integer-key (super-class base-contract) (instance-vars (state #f) (count 0)))
(define-method integer-key (initialize-instance . args) (if (not state) (instance-set! self 'state (make-instance key-store))))
(define-const-method integer-key (get-state) (assert (or (null? creator) (equal? creator (get ':message 'originator))) "only creator may dump state") (send state 'get-state))
(define-const-method integer-key (get-value key) (let* ((requestor (get ':message 'originator)) (counter (send state 'get key))) (assert (send counter 'is-owner? requestor) "only the current owner may get the value of a counter" requestor) (send counter 'get-value)))
(define-method integer-key (create key . initial-value) (let ((value (if (pair? initial-value) (coerce-number (car initial-value)) 0))) (assert (and (integer? value) (<= 0 value)) "initialization value must not be negative") (let* ((requestor (get ':message 'originator)) (counter (make-instance escrow-counter (key key) (value value) (owner requestor)))) (send state 'create key counter) #t)))
(define-method integer-key (inc key . oparam) (let ((value (if (pair? oparam) (coerce-number (car oparam)) 1))) (assert (and (integer? value) (< 0 value)) "increment must be positive integer" value) (let* ((requestor (get ':message 'originator)) (counter (send state 'get key))) (assert (send counter 'is-active?) "counter must be active to modify") (send counter 'inc value) #t)))
(define-method integer-key (dec key . oparam) (let ((value (if (pair? oparam) (coerce-number (car oparam)) 1))) (assert (and (integer? value) (< 0 value)) "decrement must be positive integer" value) (let* ((requestor (get ':message 'originator)) (counter (send state 'get key))) (assert (send counter 'is-active?) "counter must be active to modify") (assert (send counter 'is-owner? requestor) "only the current owner may decrement the value of a counter" requestor) (send counter 'dec value) #t)))
(define-method integer-key (xfer src dst param) (let ((value (coerce-number param))) (assert (and (integer? value) (< 0 value)) "amount must be positive integer" value) (assert (not (equal? src dst)) "source and destination must be different" src dst) (let* ((requestor (get ':message 'originator)) (scounter (send state 'get src)) (dcounter (send state 'get dst))) (assert (send scounter 'is-owner? requestor) "only the current owner may decrement the value of a counter" requestor) (assert (send scounter 'is-active?) "counter must be active to transfer") (send scounter 'dec value) (send dcounter 'inc value) #t)))
(define-method integer-key (transfer-ownership key new-owner) (let* ((requestor (get ':message 'originator)) (counter (send state 'get key))) (assert (send counter 'is-owner? requestor) "only the current owner may transfer ownership" requestor) (assert (send counter 'is-active?) "counter must be active to transfer") (send counter 'set-owner new-owner)))
(define-method integer-key (escrow key agent-public-key) (let* ((requestor (get ':message 'originator)) (counter (send state 'get key))) (assert (send counter 'is-owner? requestor) "only the current owner may escrow the value" requestor) (send counter 'deactivate agent-public-key) #t))
(define-const-method integer-key (escrow-attestation key) (let* ((requestor (get ':message 'originator)) (counter (send state 'get key))) (assert (send counter 'is-owner? requestor) "only owner may retrieve escrow status" requestor) (assert (not (send counter 'is-active?)) "counter has not been escrowed") (let* ((externalized (send counter 'externalize)) (dependencies (list (list (get ':contract 'id) (get ':contract 'state)))) (expression (list externalized dependencies)) (signature (send contract-signing-keys 'sign-expression expression))) (list externalized dependencies signature))))
(define-method integer-key (disburse key dependencies signature) (let* ((requestor (get ':message 'originator)) (counter (send state 'get key))) (assert (send counter 'is-owner? requestor) "only the current owner may disburse the value" requestor) (assert (not (send counter 'is-active?)) "counter has not been escrowed") (let* ((externalized (send counter 'externalize)) (expression (list externalized dependencies)) (public-key (send counter 'get-escrow-key)) (agent-keys (make-instance signing-keys (public-key public-key) (private-key "")))) (assert (send agent-keys 'verify-expression expression signature) "signature mismatch" signature) (if (pair? dependencies) (put ':ledger 'dependencies dependencies)) (send counter 'activate) #t)))
(define-method integer-key (exchange-ownership key1 key2 dependencies signature) (let* ((requestor (get ':message 'originator)) (counter1 (send state 'get key1)) (counter2 (send state 'get key2))) (assert (send counter1 'is-owner? requestor) "exchange can only be initiated by the owner of a counter" requestor) (assert (not (send counter1 'is-active?)) "counter has not been escrowed" key1) (assert (not (send counter2 'is-active?)) "counter has not been escrowed" key2) (let ((escrow1 (send counter1 'get-escrow-key)) (escrow2 (send counter2 'get-escrow-key))) (assert (string=? escrow1 escrow2) "exchange requires escrow by the same entity") (let* ((agent-keys (make-instance signing-keys (public-key escrow1) (private-key ""))) (external1 (send counter1 'externalize)) (external2 (send counter2 'externalize)) (expression (list external1 external2 dependencies))) (assert (send agent-keys 'verify-expression expression signature) "signature mismatch" signature))) (let ((owner1 (send counter1 'get-owner)) (owner2 (send counter2 'get-owner))) (if (pair? dependencies) (put ':ledger 'dependencies dependencies)) (send counter1 'activate) (send counter1 'set-owner owner2) (send counter2 'activate) (send counter2 'set-owner owner1) #t)))
