(define-macro (assert pred . message) `(if (not ,pred) (throw ,@message)))(define (coerce-number value) (if (number? value) value (string->number value)))(define-class signing-keys (instance-vars (_keys_ (ecdsa-create-signing-keys)) (private-key (car _keys_)) (public-key (cadr _keys_))))(define-method signing-keys (get-public-signing-key) public-key)(define-method signing-keys (sign message) (assert (string? message) "message must be a string" message) (ecdsa-sign-message message private-key))(define-method signing-keys (sign-expression expression) (send self 'sign (expression->string expression)))(define-method signing-keys (verify message signature) (assert (string? message) "message must be a string" message) (assert (string? signature) "signature must be a string" signature) (ecdsa-verify-signature message signature public-key))(define-method signing-keys (verify-expression expression signature) (send self 'verify (expression->string expression) signature))(define-class encryption-keys (instance-vars (_keys_ (rsa-create-keys)) (private-key (car _keys_)) (public-key (cadr _keys_))))(define-method encryption-keys (get-public-encryption-key) public-key)(define-method encryption-keys (encrypt-expression expression) (send self 'encrypt (expression->string expression)))(define-method encryption-keys (encrypt message) (assert (string? message) "message must be a string" message) (rsa-encrypt message public-key))(define-method encryption-keys (decrypt-expression cipher) (string->expression (send self 'decrypt cipher)))(define-method encryption-keys (decrypt cipher) (assert (string? cipher) "cipher text must be a string" cipher) (rsa-decrypt cipher private-key))(define-class base-contract (instance-vars (creator (get ':message 'originator)) (contract-signing-keys (make-instance signing-keys)) (contract-encryption-keys (make-instance encryption-keys))))(define-method base-contract (get-creator) creator)(define-method base-contract (get-public-encryption-key) (send contract-encryption-keys 'get-public-encryption-key))(define-method base-contract (get-public-signing-key) (send contract-signing-keys 'get-public-signing-key))(define-class counter (instance-vars (key "") (value 0) (owner (get ':message 'originator)) (active #t)))(define-method counter (externalize . args) (if (member 'full args) `(make-instance ,((*colon-hook* 'class-name oops) self) (key ,key) (value ,value) (owner ,owner) (active ,active)) `(make-instance ,((*colon-hook* 'class-name oops) self) (key ,key) (value ,value) (owner ,owner))))(define-method counter (serialize) (let ((op (open-output-string))) (write (send self 'externalize) op) (get-output-string op)))(define-method counter (get-key) key)(define-method counter (get-value) value)(define-method counter (inc v) (assert active "cannot change the value of an inactive counter") (instance-set! self 'value (+ value v)))(define-method counter (dec v) (assert active "cannot change the value of an inactive counter") (assert (<= v value) "decrement must be less than the current value") (instance-set! self 'value (- value v)))(define-method counter (is-less-than? c) (assert (or (instance? c) (integer? c)) "invalid value for comparison" c) (if (instance? c) (< value (send c 'get-value)) (< value c)))(define-method counter (is-greater-than? c) (assert (or (instance? c) (integer? c)) "invalid value for comparison" c) (if (instance? c) (> value (send c 'get-value)) (> value c)))(define-method counter (get-owner) owner)(define-method counter (set-owner new-owner) (assert active "cannot change the owner of an inactive counter") (instance-set! self 'owner new-owner))(define-method counter (is-owner? requestor) (or (null? owner) (string=? owner requestor)))(define-method counter (is-active?) active)(define-method counter (deactivate) (assert active "cannot deactivate an inactive counter") (instance-set! self 'active #f))(define-method counter (activate) (assert (not active) "cannot activate an active counter") (instance-set! self 'active #t))(define-class escrow-counter (super-class counter) (instance-vars (escrow-key "")))(define-method counter (externalize . args) (if (member 'full args) `((key ,key) (value ,value) (owner ,owner) (active ,active) (escrow-key ,escrow-key)) `((key ,key) (value ,value) (owner ,owner))))(define-method escrow-counter (get-escrow-key) (assert (not active) "counter is not in escrow") escrow-key)(define-method escrow-counter (set-escrow-key ekey) (assert (not active) "counter is not in escrow") (instance-set! self 'escrow-key ekey))(define-method escrow-counter (clear-escrow-key) (assert (not active) "counter is not in escrow") (instance-set! self 'escrow-key ""))(define-method escrow-counter (deactivate . args) (assert active "cannot deactivate an inactive counter") (instance-set! self 'active #f) (let ((public-key (if (pair? args) (car args) ""))) (instance-set! self 'escrow-key public-key)))(define-method escrow-counter (activate) (assert (not active) "cannot activate an active counter") (instance-set! self 'active #t) (instance-set! self 'escrow-key ""))(define hash-package (package (define (hash-char char n) (modulo (char->integer char))) (define (hash-symbol sym n) (hash-string (symbol->string sym) n)) (define (hash-number num n) (if (integer? num) (modulo num n) (hash-string (number->string num) n))) (define (hash-string str n) (let ((len (string-length str))) (if (> len 5) (let loop ((h (modulo 264 n)) (i 5)) (if (positive? i) (loop (modulo (+ (* h 256) (char->integer (string-ref str (modulo h len)))) n) (- i 1)) h)) (let loop ((h (- n 1)) (i (- len 1))) (if (>= i 0) (loop (modulo (+ (* h 256) (char->integer (string-ref str i))) n) (- i 1)) h))))) (define (hash-vector vect n) (let ((len (vector-length vect))) (if (> len 5) (let loop ((h (- n 1)) (i 5)) (if (positive? i) (loop (modulo (+ (* h 256) (hash-object (vector-ref vect (modulo h len)) n)) n) (- i 1)) h)) (let loop ((h (- n 1)) (i len)) (if (positive? i) (loop (modulo (+ (* h 256) (hash-object (vector-ref vect (- i 1)) n)) n) (- i 1)) h))))) (define (hash-pair pair n) (let ((v1 (hash-object (car pair) n)) (v2 (hash-object (cdr pair) n))) (modulo (+ v1 v2) n))) (define (hash-object obj n) (cond ((number? obj) (hash-number obj n)) ((char? obj) (hash-char obj n)) ((symbol? obj) (hash-symbol obj n)) ((string? obj) (hash-string obj n)) ((vector? obj) (hash-vector obj n)) ((pair? obj) (hash-pair obj n)) ((null? obj) (modulo 256 n)) ((boolean? obj) (modulo (if obj 257 258) n)) ((eof-object? obj) (modulo 259 n)) ((input-port? obj) (modulo 260 n)) ((output-port? obj) (modulo 261 n)) ((procedure? obj) (modulo 262 n)) (else (modulo 263 n))))))(define hash (*colon-hook* 'hash-object hash-package))(define hashv (*colon-hook* 'hash-object hash-package))(define alist-package (package (define (predicate->asso pred) (cond ((eq? eq? pred) assq) ((eq? = pred) assv) ((eq? eqv? pred) assv) ((eq? char=? pred) assv) ((eq? equal? pred) assoc) ((eq? string=? pred) assoc) (else (lambda (key alist) (let l ((al alist)) (cond ((null? al) #f) ((pred key (caar al)) (car al)) (else (l (cdr al))))))))) (define (inquirer pred) (let ((assofun (predicate->asso pred))) (lambda (alist key) (let ((pair (assofun key alist))) (and pair (cdr pair)))))) (define (associator pred) (let ((assofun (predicate->asso pred))) (lambda (alist key val) (let* ((pair (assofun key alist))) (cond (pair (set-cdr! pair val) alist) (else (cons (cons key val) alist))))))) (define (remover pred) (lambda (alist key) (cond ((null? alist) alist) ((pred key (caar alist)) (cdr alist)) ((null? (cdr alist)) alist) ((pred key (caadr alist)) (set-cdr! alist (cddr alist)) alist) (else (let l ((al (cdr alist))) (cond ((null? (cdr al)) alist) ((pred key (caadr al)) (set-cdr! al (cddr al)) alist) (else (l (cdr al))))))))) (define (alist-map proc alist) (map (lambda (pair) (cons (car pair) (proc (car pair) (cdr pair)))) alist)) (define (alist-for-each proc alist) (for-each (lambda (pair) (proc (car pair) (cdr pair))) alist))))(define hashtab-package (package (define (make-hash-table k) (make-vector k '())) (define (predicate->hash pred) (cond ((eq? pred eq?) hashq) ((eq? pred eqv?) hashv) ((eq? pred equal?) hash) ((eq? pred =) hashv) ((eq? pred char=?) hashv) ((eq? pred char-ci=?) hashv) ((eq? pred string=?) hash) ((eq? pred string-ci=?) hash) (else (slib:error "unknown predicate for hash" pred)))) (define (predicate->hash-asso pred) (let ((hashfun (predicate->hash pred)) (asso ((*colon-hook* 'predicate->asso alist-package) pred))) (lambda (key hashtab) (asso key (vector-ref hashtab (hashfun key (vector-length hashtab))))))) (define (inquirer pred) (let ((hashfun (predicate->hash pred)) (ainq ((*colon-hook* 'inquirer alist-package) pred))) (lambda (hashtab key) (ainq (vector-ref hashtab (hashfun key (vector-length hashtab))) key)))) (define (associator pred) (let ((hashfun (predicate->hash pred)) (asso ((*colon-hook* 'associator alist-package) pred))) (lambda (hashtab key val) (let* ((num (hashfun key (vector-length hashtab)))) (vector-set! hashtab num (asso (vector-ref hashtab num) key val))) hashtab))) (define (remover pred) (let ((hashfun (predicate->hash pred)) (arem ((*colon-hook* 'remover alist-package) pred))) (lambda (hashtab key) (let* ((num (hashfun key (vector-length hashtab)))) (vector-set! hashtab num (arem (vector-ref hashtab num) key))) hashtab))) (define (hash-map proc ht) (define nht (make-vector (vector-length ht))) (do ((i (+ -1 (vector-length ht)) (+ -1 i))) ((negative? i) nht) (vector-set! nht i ((*colon-hook* 'alist-map alist-package) proc (vector-ref ht i))))) (define (hash-for-each proc ht) (do ((i (+ -1 (vector-length ht)) (+ -1 i))) ((negative? i)) ((*colon-hook* 'alist-for-each alist-package) proc (vector-ref ht i))))))(define-class key-store (instance-vars (store ((*colon-hook* 'make-hash-table hashtab-package) 347))) (class-vars (_ht-set_ ((*colon-hook* 'associator hashtab-package) string=?)) (_ht-get_ ((*colon-hook* 'inquirer hashtab-package) string=?)) (_ht-del_ ((*colon-hook* 'remover hashtab-package) string=?))))(define-method key-store (get-state) (let ((result '())) ((*colon-hook* 'hash-for-each hashtab-package) (lambda (key value) (set! result (cons (list key (send value 'externalize 'full)) result))) store) result))(define-method key-store (create key value) (assert (not (_ht-get_ store key)) "key already exists" key) (_ht-set_ store key value) #t)(define-method key-store (exists? key) (let ((value (_ht-get_ store key))) (instance? value)))(define-method key-store (get key) (let ((value (_ht-get_ store key))) (assert value "key does not exist" key) value))(define-method key-store (set key value) (let ((oldvalue (_ht-get_ store key))) (assert oldvalue "key does not exist" key) (_ht-del_ store key) (_ht-set_ store key value)))(define-method key-store (del key) (let ((value (_ht-get_ store key))) (assert value "key does not exist" key) (_ht-del_ store key)))(define-class bid-store (super-class key-store) (instance-vars (minimum-bid 0)))(define-method bid-store (set-bid identity new-bid) (assert (instance? new-bid) "bid must be an instance of bid class" new-bid) (if (send self 'exists? identity) (let ((current-bid (send self 'get identity))) (assert (not (send current-bid 'is-active?)) "old bid must be cancelled before a new one is submitted" identity) (send self 'set identity new-bid)) (send self 'create identity new-bid)))(define-method bid-store (del-bid identity) (let ((current-bid (send self 'get identity))) (assert (instance? current-bid) "unknown identity" identity) (send current-bid 'deactivate)))(define-method bid-store (get-active-bid identity . flags) (let ((current-bid (send self 'get identity))) (assert (instance? current-bid) "unknown identity" identity) (assert (send current-bid 'is-active?) "bid is not active" identity) (if (member 'externalize flags) (send current-bid 'externalize) current-bid)))(define-method bid-store (get-cancelled-bid identity . flags) (let ((current-bid (send self 'get identity))) (assert (instance? current-bid) "unknown identity" identity) (assert (not (send current-bid 'is-active?)) "bid is not active" identity) (if (member 'externalize flags) (send current-bid 'externalize) current-bid)))(define-method bid-store (max-bid . flags) (let ((high-bid ())) ((*colon-hook* 'hash-for-each hashtab-package) (lambda (k b) (if (send b 'is-active?) (if (or (null? high-bid) (send b 'is-greater-than? high-bid)) (set! high-bid b)))) store) (if (member 'externalize flags) (send high-bid 'externalize) high-bid)))(define-class auction (super-class base-contract) (class-vars (_bid-type_ escrow-counter)) (instance-vars (auction-inited #f) (auction-primed #f) (auction-closed #f) (offered-asset #f) (maximum-bid #f) (asset-contract-public-key "") (state (make-instance bid-store))))(define-method auction (initialize asset-key) (assert (not auction-inited) "can set the asset key only one time") (instance-set! self 'asset-contract-public-key asset-key) (instance-set! self 'auction-inited #t) #t)(define-method auction (prime-auction* bidinfo dependencies signature) (let ((initial-bid (make-instance* escrow-counter bidinfo))) (send self 'prime-auction initial-bid dependencies signature)))(define-method auction (prime-auction initial-bid dependencies signature) "Prime the auction with the initial counter" (assert auction-inited "must initialize the auction before priming") (assert (not auction-primed) "cannot prime an auction that is already active") (assert (instance? initial-bid) "not an instance" initial-bid) (let ((bidclass ((*colon-hook* 'class-name oops) initial-bid))) (assert (eqv? bidclass ((*colon-hook* 'class-name oops) _bid-type_)) "wrong bid type" bidclass)) (let ((requestor (get ':message 'originator))) (assert (string=? creator requestor) "only the creator of the auction may prime it" requestor) (assert (send initial-bid 'is-owner? requestor) "initial asset must be owned by the creator" requestor)) (let* ((externalized (send initial-bid 'externalize)) (expression (list externalized dependencies)) (agent-keys (make-instance signing-keys (public-key asset-contract-public-key) (private-key "")))) (assert (send agent-keys 'verify-expression expression signature) "Bid must be signed by the asset contract" expression)) (instance-set! self 'offered-asset initial-bid) (send state 'create creator initial-bid) (instance-set! self 'auction-primed #t) (if (pair? dependencies) (put ':ledger 'dependencies dependencies)) #t)(define-method auction (get-offered-asset) (assert auction-primed "bidding is not active") (assert (not auction-closed) "the auction has completed") (list (send offered-asset 'get-key) (send offered-asset 'get-value)))(define-method auction (submit-bid* bidinfo dependencies signature) (let ((initial-bid (make-instance* escrow-counter bidinfo))) (send self 'submit-bid initial-bid dependencies signature)))(define-method auction (submit-bid bid dependencies signature) (assert auction-primed "bidding is not active") (assert (not auction-closed) "the auction has completed") (assert (instance? bid) "not an instance" bid) (let ((bidclass ((*colon-hook* 'class-name oops) bid))) (assert (eqv? bidclass ((*colon-hook* 'class-name oops) _bid-type_)) "wrong bid type" bidclass)) (let* ((externalized (send bid 'externalize)) (expression (list externalized dependencies)) (agent-keys (make-instance signing-keys (public-key asset-contract-public-key) (private-key "")))) (assert (send agent-keys 'verify-expression expression signature) "Bid must be signed by the asset contract" expression)) (let ((requestor (get ':message 'originator))) (assert (send bid 'is-owner? requestor) "only the owner of a bid may submit the bid" requestor) (send state 'set-bid requestor bid)) (if (pair? dependencies) (put ':ledger 'dependencies dependencies)) #t)(define-method auction (cancel-bid) (assert auction-primed "bidding is not active") (let* ((requestor (get ':message 'originator)) (bid (send state 'get-active-bid requestor))) (send bid 'deactivate)) #t)(define-method auction (cancel-attestation) (assert auction-primed "bidding is not active") (let* ((requestor (get ':message 'originator)) (externalized (send state 'get-cancelled-bid requestor 'externalize)) (dependencies (list (list (get ':contract 'id) (get ':contract 'state)))) (expression (list externalized dependencies)) (signature (send contract-signing-keys 'sign-expression expression))) (list externalized dependencies signature)))(define-method auction (check-bid) (assert auction-primed "bidding is not active") (assert (not auction-closed) "the auction has completed") (let* ((requestor (get ':message 'originator))) (send state 'get-active-bid requestor 'externalize)))(define-method auction (max-bid) (assert auction-primed "bidding is not active") (assert (not auction-closed) "the auction has completed") (let ((maxbid (send state 'max-bid))) (send maxbid 'get-value)))(define-method auction (close-bidding) (assert auction-primed "cannot close auction that has not started") (assert (not auction-closed) "the auction has already completed") (let ((requestor (get ':message 'originator))) (assert (string=? requestor creator) "only the auction creator may close bidding")) (instance-set! self 'auction-closed #t) (instance-set! self 'maximum-bid (send state 'max-bid)) (send maximum-bid 'deactivate) #t)(define-method auction (exchange-attestation) (let ((requestor (get ':message 'originator))) (assert (string=? requestor creator) "only the auction creator may generate the exchange attestation" requestor)) (assert auction-closed "cannot generate exchange attestation until the auction is closed") (let* ((offered (send offered-asset 'externalize)) (maxbid (send maximum-bid 'externalize)) (dependencies (list (list (get ':contract 'id) (get ':contract 'state)))) (expression (list offered maxbid dependencies)) (signature (send contract-signing-keys 'sign-expression expression))) (list offered maxbid dependencies signature)))